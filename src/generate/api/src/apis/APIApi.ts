/* tslint:disable */
/* eslint-disable */
/**
 * 체험콕 서비스
 * 체험단 모집 및 관리 서비스 API
 *
 * The version of the OpenAPI document: v1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  CampaignApplicationRequest,
  CreateCampaignRequest,
  ErrorResponseDTO,
  KakaoAuthRequest,
  LoginResponseDTO,
  NicknameUpdateRequest,
  PresignedUrlRequest,
  ProfileImageUpdateRequest,
  RefreshTokenRequest,
  Success,
  TokenRefreshResponseDTO,
  UserProfileResponseDTO,
  UserUpdateRequest,
} from '../models/index';
import {
    CampaignApplicationRequestFromJSON,
    CampaignApplicationRequestToJSON,
    CreateCampaignRequestFromJSON,
    CreateCampaignRequestToJSON,
    ErrorResponseDTOFromJSON,
    ErrorResponseDTOToJSON,
    KakaoAuthRequestFromJSON,
    KakaoAuthRequestToJSON,
    LoginResponseDTOFromJSON,
    LoginResponseDTOToJSON,
    NicknameUpdateRequestFromJSON,
    NicknameUpdateRequestToJSON,
    PresignedUrlRequestFromJSON,
    PresignedUrlRequestToJSON,
    ProfileImageUpdateRequestFromJSON,
    ProfileImageUpdateRequestToJSON,
    RefreshTokenRequestFromJSON,
    RefreshTokenRequestToJSON,
    SuccessFromJSON,
    SuccessToJSON,
    TokenRefreshResponseDTOFromJSON,
    TokenRefreshResponseDTOToJSON,
    UserProfileResponseDTOFromJSON,
    UserProfileResponseDTOToJSON,
    UserUpdateRequestFromJSON,
    UserUpdateRequestToJSON,
} from '../models/index';

export interface ApplyForCampaignRequest {
    authorization: string;
    campaignApplicationRequest: CampaignApplicationRequest;
}

export interface CancelApplicationRequest {
    authorization: string;
    applicationId: number;
}

export interface CheckApplicationStatusRequest {
    authorization: string;
    campaignId: number;
}

export interface CheckClientRoleRequest {
    authorization: string;
}

export interface CheckUserRoleRequest {
    authorization: string;
}

export interface CreateCampaignOperationRequest {
    authorization: string;
    createCampaignRequest: CreateCampaignRequest;
}

export interface DeleteAccountRequest {
    authorization: string;
}

export interface GenerateCampaignImagePresignedUrlRequest {
    authorization: string;
    presignedUrlRequest: PresignedUrlRequest;
}

export interface GeneratePresignedUrlRequest {
    authorization: string;
    presignedUrlRequest: PresignedUrlRequest;
}

export interface GenerateProfileImagePresignedUrlRequest {
    authorization: string;
    presignedUrlRequest: PresignedUrlRequest;
}

export interface GetCampaignApplicantsRequest {
    authorization: string;
    campaignId: number;
    page?: number;
    size?: number;
    applicationStatus?: string;
}

export interface GetCampaignBasicInfoRequest {
    campaignId: number;
}

export interface GetCampaignDetailInfoRequest {
    campaignId: number;
}

export interface GetCampaignKeywordsRequest {
    campaignId: number;
}

export interface GetCampaignMissionGuideRequest {
    campaignId: number;
}

export interface GetCampaignThumbnailRequest {
    campaignId: number;
}

export interface GetDeadlineSoonCampaignsRequest {
    page?: number;
    size?: number;
    categoryType?: string;
    categoryName?: string;
    campaignType?: string;
    includePaging?: boolean;
}

export interface GetDeliveryCampaignsRequest {
    page?: number;
    size?: number;
    categoryName?: string;
    campaignTypes?: string;
    sort?: string;
    includePaging?: boolean;
}

export interface GetLatestCampaignsRequest {
    page?: number;
    size?: number;
    categoryType?: string;
    categoryName?: string;
    campaignType?: string;
    includePaging?: boolean;
}

export interface GetMyApplicationsRequest {
    authorization: string;
    page?: number;
    size?: number;
    applicationStatus?: string;
}

export interface GetMyCampaignSummaryRequest {
    authorization: string;
}

export interface GetPopularCampaignsRequest {
    page?: number;
    size?: number;
    categoryType?: string;
    categoryName?: string;
    campaignType?: string;
    includePaging?: boolean;
}

export interface GetProfileRequest {
    authorization: string;
}

export interface GetRealtimeTrendingKeywordsRequest {
    limit?: number;
}

export interface GetSearchSuggestionsRequest {
    q: string;
    limit?: number;
}

export interface GetVisitCampaignsRequest {
    page?: number;
    size?: number;
    categoryName?: string;
    campaignTypes?: string;
    sort?: string;
    includePaging?: boolean;
}

export interface KakaoLoginRequest {
    kakaoAuthRequest: KakaoAuthRequest;
}

export interface LogoutRequest {
    authorization: string;
}

export interface RedirectToKakaoLoginRequest {
    redirectUri: string;
}

export interface RefreshRequest {
    authorization: string;
    refreshTokenRequest: RefreshTokenRequest;
}

export interface SearchCampaignsRequest {
    keyword: string;
    page?: number;
    size?: number;
    includePaging?: boolean;
}

export interface UpdateCampaignRequest {
    authorization: string;
    campaignId: number;
    createCampaignRequest: CreateCampaignRequest;
}

export interface UpdateNicknameRequest {
    authorization: string;
    nicknameUpdateRequest: NicknameUpdateRequest;
}

export interface UpdateProfileRequest {
    authorization: string;
    userUpdateRequest: UserUpdateRequest;
}

export interface UpdateProfileImageRequest {
    authorization: string;
    profileImageUpdateRequest: ProfileImageUpdateRequest;
}

/**
 * 
 */
export class APIApi extends runtime.BaseAPI {

    /**
     * 인플루언서가 선택한 캠페인에 참여 신청합니다.  ### 주요 기능 - 캠페인 참여 의사를 표시하고 신청 정보를 등록합니다. - 한 사용자는 동일한 캠페인에 중복 신청할 수 없습니다. - 신청 마감일이 지난 캠페인은 신청할 수 없습니다.  ### 응답 필드 설명 - **applicationStatus**: 신청 상태 (PENDING: 대기중, APPROVED: 선정됨, REJECTED: 거절됨, COMPLETED: 완료됨) - **hasApplied**: 신청 여부 (true: 신청함, false: 신청하지 않음)  ### 신청 상태 설명 - **PENDING**: 신청 접수 상태 (기본값) - **APPROVED**: 선정된 신청 - **REJECTED**: 거절된 신청 - **COMPLETED**: 체험 및 리뷰까지 완료한 신청
     * 캠페인 신청
     */
    async applyForCampaignRaw(requestParameters: ApplyForCampaignRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.authorization === null || requestParameters.authorization === undefined) {
            throw new runtime.RequiredError('authorization','Required parameter requestParameters.authorization was null or undefined when calling applyForCampaign.');
        }

        if (requestParameters.campaignApplicationRequest === null || requestParameters.campaignApplicationRequest === undefined) {
            throw new runtime.RequiredError('campaignApplicationRequest','Required parameter requestParameters.campaignApplicationRequest was null or undefined when calling applyForCampaign.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['Authorization'] = String(requestParameters.authorization);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/campaign-applications`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CampaignApplicationRequestToJSON(requestParameters.campaignApplicationRequest),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * 인플루언서가 선택한 캠페인에 참여 신청합니다.  ### 주요 기능 - 캠페인 참여 의사를 표시하고 신청 정보를 등록합니다. - 한 사용자는 동일한 캠페인에 중복 신청할 수 없습니다. - 신청 마감일이 지난 캠페인은 신청할 수 없습니다.  ### 응답 필드 설명 - **applicationStatus**: 신청 상태 (PENDING: 대기중, APPROVED: 선정됨, REJECTED: 거절됨, COMPLETED: 완료됨) - **hasApplied**: 신청 여부 (true: 신청함, false: 신청하지 않음)  ### 신청 상태 설명 - **PENDING**: 신청 접수 상태 (기본값) - **APPROVED**: 선정된 신청 - **REJECTED**: 거절된 신청 - **COMPLETED**: 체험 및 리뷰까지 완료한 신청
     * 캠페인 신청
     */
    async applyForCampaign(requestParameters: ApplyForCampaignRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.applyForCampaignRaw(requestParameters, initOverrides);
    }

    /**
     * 인플루언서가 캠페인 신청을 취소합니다.  ### 주요 기능 - 본인이 신청한 캠페인만 취소할 수 있습니다. - 이미 선정된 신청(APPROVED)은 취소할 수 없습니다. - 취소된 신청은 데이터베이스에서 완전히 삭제됩니다.
     * 신청 취소
     */
    async cancelApplicationRaw(requestParameters: CancelApplicationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.authorization === null || requestParameters.authorization === undefined) {
            throw new runtime.RequiredError('authorization','Required parameter requestParameters.authorization was null or undefined when calling cancelApplication.');
        }

        if (requestParameters.applicationId === null || requestParameters.applicationId === undefined) {
            throw new runtime.RequiredError('applicationId','Required parameter requestParameters.applicationId was null or undefined when calling cancelApplication.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['Authorization'] = String(requestParameters.authorization);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/campaign-applications/{applicationId}`.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters.applicationId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * 인플루언서가 캠페인 신청을 취소합니다.  ### 주요 기능 - 본인이 신청한 캠페인만 취소할 수 있습니다. - 이미 선정된 신청(APPROVED)은 취소할 수 없습니다. - 취소된 신청은 데이터베이스에서 완전히 삭제됩니다.
     * 신청 취소
     */
    async cancelApplication(requestParameters: CancelApplicationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.cancelApplicationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 사용자가 특정 캠페인에 신청했는지 여부와 상태를 확인합니다.  ### 주요 기능 - 로그인한 사용자가 특정 캠페인에 이미 신청했는지 확인합니다. - 신청한 경우 해당 신청의 상태 정보도 함께 제공합니다.  ### 응답 필드 설명 - **id**: 신청 ID - **applicationStatus**: 신청 상태 (PENDING, APPROVED, REJECTED, COMPLETED) - **hasApplied**: 신청 여부 (true: 신청함, false: 신청하지 않음) - **campaign, user**: 신청한 경우에만 제공되는 연관 정보  ### 사용 예시 - 캠페인 상세 페이지에서 \'신청하기\' 버튼의 활성화/비활성화 여부 결정 - 이미 신청한 캠페인에 대해 신청 상태 표시
     * 캠페인 신청 상태 확인
     */
    async checkApplicationStatusRaw(requestParameters: CheckApplicationStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.authorization === null || requestParameters.authorization === undefined) {
            throw new runtime.RequiredError('authorization','Required parameter requestParameters.authorization was null or undefined when calling checkApplicationStatus.');
        }

        if (requestParameters.campaignId === null || requestParameters.campaignId === undefined) {
            throw new runtime.RequiredError('campaignId','Required parameter requestParameters.campaignId was null or undefined when calling checkApplicationStatus.');
        }

        const queryParameters: any = {};

        if (requestParameters.campaignId !== undefined) {
            queryParameters['campaignId'] = requestParameters.campaignId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['Authorization'] = String(requestParameters.authorization);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/campaign-applications/check`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * 사용자가 특정 캠페인에 신청했는지 여부와 상태를 확인합니다.  ### 주요 기능 - 로그인한 사용자가 특정 캠페인에 이미 신청했는지 확인합니다. - 신청한 경우 해당 신청의 상태 정보도 함께 제공합니다.  ### 응답 필드 설명 - **id**: 신청 ID - **applicationStatus**: 신청 상태 (PENDING, APPROVED, REJECTED, COMPLETED) - **hasApplied**: 신청 여부 (true: 신청함, false: 신청하지 않음) - **campaign, user**: 신청한 경우에만 제공되는 연관 정보  ### 사용 예시 - 캠페인 상세 페이지에서 \'신청하기\' 버튼의 활성화/비활성화 여부 결정 - 이미 신청한 캠페인에 대해 신청 상태 표시
     * 캠페인 신청 상태 확인
     */
    async checkApplicationStatus(requestParameters: CheckApplicationStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.checkApplicationStatusRaw(requestParameters, initOverrides);
    }

    /**
     * 현재 사용자가 CLIENT 권한을 가지고 있는지 확인합니다.
     * CLIENT 권한 검사
     */
    async checkClientRoleRaw(requestParameters: CheckClientRoleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Success>> {
        if (requestParameters.authorization === null || requestParameters.authorization === undefined) {
            throw new runtime.RequiredError('authorization','Required parameter requestParameters.authorization was null or undefined when calling checkClientRole.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['Authorization'] = String(requestParameters.authorization);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/auth/check-client`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SuccessFromJSON(jsonValue));
    }

    /**
     * 현재 사용자가 CLIENT 권한을 가지고 있는지 확인합니다.
     * CLIENT 권한 검사
     */
    async checkClientRole(requestParameters: CheckClientRoleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Success> {
        const response = await this.checkClientRoleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 현재 사용자가 USER 권한을 가지고 있는지 확인합니다.
     * USER 권한 검사
     */
    async checkUserRoleRaw(requestParameters: CheckUserRoleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Success>> {
        if (requestParameters.authorization === null || requestParameters.authorization === undefined) {
            throw new runtime.RequiredError('authorization','Required parameter requestParameters.authorization was null or undefined when calling checkUserRole.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['Authorization'] = String(requestParameters.authorization);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/auth/check-user`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SuccessFromJSON(jsonValue));
    }

    /**
     * 현재 사용자가 USER 권한을 가지고 있는지 확인합니다.
     * USER 권한 검사
     */
    async checkUserRole(requestParameters: CheckUserRoleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Success> {
        const response = await this.checkUserRoleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 새로운 인플루언서 마케팅 캠페인을 등록합니다.  ###  권한 요구사항: - **CLIENT 권한**을 가진 사용자만 등록 가능합니다 - JWT 토큰을 통한 인증이 필요합니다  ###  캠페인 일정 설정 가이드: 캠페인의 각 단계별 날짜를 올바른 순서로 설정해주세요:   **recruitmentStartDate** (모집 시작일)    └ 캠페인이 공개되어 인플루언서들이 신청을 시작할 수 있는 날짜  **applicationDeadlineDate** (신청 마감일)    └ 인플루언서들이 캠페인에 신청할 수 있는 최종 날짜    └ 모집 시작일 이후여야 함   **recruitmentEndDate** (모집 종료일)    └ 캠페인 모집 공고가 마감되는 날짜    └  신청 마감일과 같거나 이후여야 함   **selectionDate** (참여자 선정일)    └ 신청자 중에서 최종 참여자를 선정하여 발표하는 날짜    └  모집 종료일 이후여야 함  **reviewDeadlineDate** (리뷰 제출 마감일)    └ 선정된 인플루언서들이 체험 후 리뷰를 완료해야 하는 최종 날짜    └  선정일 이후여야 함 (충분한 체험 기간 고려)  - **방문형**: 맛집, 카페, 뷰티, 숙박 - **배송형**: 식품, 화장품, 생활용품, 패션, 잡화  
     * 캠페인 등록
     */
    async createCampaignRaw(requestParameters: CreateCampaignOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.authorization === null || requestParameters.authorization === undefined) {
            throw new runtime.RequiredError('authorization','Required parameter requestParameters.authorization was null or undefined when calling createCampaign.');
        }

        if (requestParameters.createCampaignRequest === null || requestParameters.createCampaignRequest === undefined) {
            throw new runtime.RequiredError('createCampaignRequest','Required parameter requestParameters.createCampaignRequest was null or undefined when calling createCampaign.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['Authorization'] = String(requestParameters.authorization);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/campaigns`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateCampaignRequestToJSON(requestParameters.createCampaignRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * 새로운 인플루언서 마케팅 캠페인을 등록합니다.  ###  권한 요구사항: - **CLIENT 권한**을 가진 사용자만 등록 가능합니다 - JWT 토큰을 통한 인증이 필요합니다  ###  캠페인 일정 설정 가이드: 캠페인의 각 단계별 날짜를 올바른 순서로 설정해주세요:   **recruitmentStartDate** (모집 시작일)    └ 캠페인이 공개되어 인플루언서들이 신청을 시작할 수 있는 날짜  **applicationDeadlineDate** (신청 마감일)    └ 인플루언서들이 캠페인에 신청할 수 있는 최종 날짜    └ 모집 시작일 이후여야 함   **recruitmentEndDate** (모집 종료일)    └ 캠페인 모집 공고가 마감되는 날짜    └  신청 마감일과 같거나 이후여야 함   **selectionDate** (참여자 선정일)    └ 신청자 중에서 최종 참여자를 선정하여 발표하는 날짜    └  모집 종료일 이후여야 함  **reviewDeadlineDate** (리뷰 제출 마감일)    └ 선정된 인플루언서들이 체험 후 리뷰를 완료해야 하는 최종 날짜    └  선정일 이후여야 함 (충분한 체험 기간 고려)  - **방문형**: 맛집, 카페, 뷰티, 숙박 - **배송형**: 식품, 화장품, 생활용품, 패션, 잡화  
     * 캠페인 등록
     */
    async createCampaign(requestParameters: CreateCampaignOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.createCampaignRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 사용자 계정을 삭제합니다.
     * 회원 탈퇴
     */
    async deleteAccountRaw(requestParameters: DeleteAccountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.authorization === null || requestParameters.authorization === undefined) {
            throw new runtime.RequiredError('authorization','Required parameter requestParameters.authorization was null or undefined when calling deleteAccount.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['Authorization'] = String(requestParameters.authorization);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/users/exit`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * 사용자 계정을 삭제합니다.
     * 회원 탈퇴
     */
    async deleteAccount(requestParameters: DeleteAccountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.deleteAccountRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 캠페인 이미지(720x720 자동 리사이징)를 업로드하기 위한 presigned URL을 생성합니다.
     * 캠페인 이미지 업로드용 Presigned URL 생성
     */
    async generateCampaignImagePresignedUrlRaw(requestParameters: GenerateCampaignImagePresignedUrlRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.authorization === null || requestParameters.authorization === undefined) {
            throw new runtime.RequiredError('authorization','Required parameter requestParameters.authorization was null or undefined when calling generateCampaignImagePresignedUrl.');
        }

        if (requestParameters.presignedUrlRequest === null || requestParameters.presignedUrlRequest === undefined) {
            throw new runtime.RequiredError('presignedUrlRequest','Required parameter requestParameters.presignedUrlRequest was null or undefined when calling generateCampaignImagePresignedUrl.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['Authorization'] = String(requestParameters.authorization);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/images/campaign/presigned-url`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PresignedUrlRequestToJSON(requestParameters.presignedUrlRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * 캠페인 이미지(720x720 자동 리사이징)를 업로드하기 위한 presigned URL을 생성합니다.
     * 캠페인 이미지 업로드용 Presigned URL 생성
     */
    async generateCampaignImagePresignedUrl(requestParameters: GenerateCampaignImagePresignedUrlRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.generateCampaignImagePresignedUrlRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * S3에 원본 크기 이미지를 업로드하기 위한 presigned URL을 생성합니다.
     * 일반 이미지 업로드용 Presigned URL 생성
     */
    async generatePresignedUrlRaw(requestParameters: GeneratePresignedUrlRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.authorization === null || requestParameters.authorization === undefined) {
            throw new runtime.RequiredError('authorization','Required parameter requestParameters.authorization was null or undefined when calling generatePresignedUrl.');
        }

        if (requestParameters.presignedUrlRequest === null || requestParameters.presignedUrlRequest === undefined) {
            throw new runtime.RequiredError('presignedUrlRequest','Required parameter requestParameters.presignedUrlRequest was null or undefined when calling generatePresignedUrl.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['Authorization'] = String(requestParameters.authorization);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/images/common/presigned-url`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PresignedUrlRequestToJSON(requestParameters.presignedUrlRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * S3에 원본 크기 이미지를 업로드하기 위한 presigned URL을 생성합니다.
     * 일반 이미지 업로드용 Presigned URL 생성
     */
    async generatePresignedUrl(requestParameters: GeneratePresignedUrlRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.generatePresignedUrlRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 프로필 이미지(100x100 자동 리사이징)를 업로드하기 위한 presigned URL을 생성합니다.
     * 프로필 이미지 업로드용 Presigned URL 생성
     */
    async generateProfileImagePresignedUrlRaw(requestParameters: GenerateProfileImagePresignedUrlRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.authorization === null || requestParameters.authorization === undefined) {
            throw new runtime.RequiredError('authorization','Required parameter requestParameters.authorization was null or undefined when calling generateProfileImagePresignedUrl.');
        }

        if (requestParameters.presignedUrlRequest === null || requestParameters.presignedUrlRequest === undefined) {
            throw new runtime.RequiredError('presignedUrlRequest','Required parameter requestParameters.presignedUrlRequest was null or undefined when calling generateProfileImagePresignedUrl.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['Authorization'] = String(requestParameters.authorization);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/images/profile/presigned-url`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PresignedUrlRequestToJSON(requestParameters.presignedUrlRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * 프로필 이미지(100x100 자동 리사이징)를 업로드하기 위한 presigned URL을 생성합니다.
     * 프로필 이미지 업로드용 Presigned URL 생성
     */
    async generateProfileImagePresignedUrl(requestParameters: GenerateProfileImagePresignedUrlRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.generateProfileImagePresignedUrlRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 모든 배너 이미지 목록을 최신순으로 조회합니다.  ### 응답 정보: - **id**: 배너 고유 식별자 - **bannerUrl**: 배너 이미지 URL - **redirectUrl**: 클릭 시 이동할 URL  ### 사용 예시: - 메인 페이지 배너 표시 - 프로모션 배너 캐러셀
     * 배너 이미지 목록 조회
     */
    async getAllBannersRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/banners`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * 모든 배너 이미지 목록을 최신순으로 조회합니다.  ### 응답 정보: - **id**: 배너 고유 식별자 - **bannerUrl**: 배너 이미지 URL - **redirectUrl**: 클릭 시 이동할 URL  ### 사용 예시: - 메인 페이지 배너 표시 - 프로모션 배너 캐러셀
     * 배너 이미지 목록 조회
     */
    async getAllBanners(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.getAllBannersRaw(initOverrides);
        return await response.value();
    }

    /**
     * CLIENT가 자신이 만든 캠페인의 신청자 목록을 조회합니다.  ### 주요 기능 - CLIENT 권한을 가진 사용자만 접근 가능합니다. - 본인이 생성한 캠페인의 신청자만 조회할 수 있습니다. - 각 신청자의 상세 정보와 SNS 플랫폼 정보를 제공합니다.  ### 응답 정보 - **사용자 기본 정보**: ID, 닉네임, 전화번호 - **SNS 플랫폼 정보**: 플랫폼 타입, 계정 URL, 팔로워 수 - **신청 정보**: 신청 ID, 신청 상태, 신청 시간  ### 필터링 옵션 (applicationStatus) - **PENDING**: 대기 중인 신청 - **APPROVED**: 선정된 신청 - **REJECTED**: 거절된 신청 - **COMPLETED**: 완료된 신청  ### 페이징 특징 - 기본 페이지 크기: 10개 - 최신 신청순으로 정렬됩니다
     * 캠페인 신청자 목록 조회
     */
    async getCampaignApplicantsRaw(requestParameters: GetCampaignApplicantsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.authorization === null || requestParameters.authorization === undefined) {
            throw new runtime.RequiredError('authorization','Required parameter requestParameters.authorization was null or undefined when calling getCampaignApplicants.');
        }

        if (requestParameters.campaignId === null || requestParameters.campaignId === undefined) {
            throw new runtime.RequiredError('campaignId','Required parameter requestParameters.campaignId was null or undefined when calling getCampaignApplicants.');
        }

        const queryParameters: any = {};

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.size !== undefined) {
            queryParameters['size'] = requestParameters.size;
        }

        if (requestParameters.applicationStatus !== undefined) {
            queryParameters['applicationStatus'] = requestParameters.applicationStatus;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['Authorization'] = String(requestParameters.authorization);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/campaign-applications/campaigns/{campaignId}/applicants`.replace(`{${"campaignId"}}`, encodeURIComponent(String(requestParameters.campaignId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * CLIENT가 자신이 만든 캠페인의 신청자 목록을 조회합니다.  ### 주요 기능 - CLIENT 권한을 가진 사용자만 접근 가능합니다. - 본인이 생성한 캠페인의 신청자만 조회할 수 있습니다. - 각 신청자의 상세 정보와 SNS 플랫폼 정보를 제공합니다.  ### 응답 정보 - **사용자 기본 정보**: ID, 닉네임, 전화번호 - **SNS 플랫폼 정보**: 플랫폼 타입, 계정 URL, 팔로워 수 - **신청 정보**: 신청 ID, 신청 상태, 신청 시간  ### 필터링 옵션 (applicationStatus) - **PENDING**: 대기 중인 신청 - **APPROVED**: 선정된 신청 - **REJECTED**: 거절된 신청 - **COMPLETED**: 완료된 신청  ### 페이징 특징 - 기본 페이지 크기: 10개 - 최신 신청순으로 정렬됩니다
     * 캠페인 신청자 목록 조회
     */
    async getCampaignApplicants(requestParameters: GetCampaignApplicantsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.getCampaignApplicantsRaw(requestParameters, initOverrides);
    }

    /**
     * 캠페인의 기본 정보(타입, 카테고리, 제목, 신청 인원, 모집 기간)를 조회합니다.
     * 캠페인 기본 정보 조회
     */
    async getCampaignBasicInfoRaw(requestParameters: GetCampaignBasicInfoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.campaignId === null || requestParameters.campaignId === undefined) {
            throw new runtime.RequiredError('campaignId','Required parameter requestParameters.campaignId was null or undefined when calling getCampaignBasicInfo.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/campaigns/{campaignId}/basic-info`.replace(`{${"campaignId"}}`, encodeURIComponent(String(requestParameters.campaignId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * 캠페인의 기본 정보(타입, 카테고리, 제목, 신청 인원, 모집 기간)를 조회합니다.
     * 캠페인 기본 정보 조회
     */
    async getCampaignBasicInfo(requestParameters: GetCampaignBasicInfoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.getCampaignBasicInfoRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 캠페인의 상세 정보(제품/서비스 정보, 선정기준, 일정)를 조회합니다.
     * 캠페인 상세 정보 조회
     */
    async getCampaignDetailInfoRaw(requestParameters: GetCampaignDetailInfoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.campaignId === null || requestParameters.campaignId === undefined) {
            throw new runtime.RequiredError('campaignId','Required parameter requestParameters.campaignId was null or undefined when calling getCampaignDetailInfo.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/campaigns/{campaignId}/detail-info`.replace(`{${"campaignId"}}`, encodeURIComponent(String(requestParameters.campaignId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * 캠페인의 상세 정보(제품/서비스 정보, 선정기준, 일정)를 조회합니다.
     * 캠페인 상세 정보 조회
     */
    async getCampaignDetailInfo(requestParameters: GetCampaignDetailInfoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.getCampaignDetailInfoRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 캠페인의 필수 포함 키워드 목록을 조회합니다.
     * 캠페인 필수 키워드 조회
     */
    async getCampaignKeywordsRaw(requestParameters: GetCampaignKeywordsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.campaignId === null || requestParameters.campaignId === undefined) {
            throw new runtime.RequiredError('campaignId','Required parameter requestParameters.campaignId was null or undefined when calling getCampaignKeywords.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/campaigns/{campaignId}/keywords`.replace(`{${"campaignId"}}`, encodeURIComponent(String(requestParameters.campaignId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * 캠페인의 필수 포함 키워드 목록을 조회합니다.
     * 캠페인 필수 키워드 조회
     */
    async getCampaignKeywords(requestParameters: GetCampaignKeywordsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.getCampaignKeywordsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 캠페인의 미션 가이드 정보를 조회합니다.
     * 캠페인 미션 가이드 조회
     */
    async getCampaignMissionGuideRaw(requestParameters: GetCampaignMissionGuideRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.campaignId === null || requestParameters.campaignId === undefined) {
            throw new runtime.RequiredError('campaignId','Required parameter requestParameters.campaignId was null or undefined when calling getCampaignMissionGuide.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/campaigns/{campaignId}/mission-guide`.replace(`{${"campaignId"}}`, encodeURIComponent(String(requestParameters.campaignId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * 캠페인의 미션 가이드 정보를 조회합니다.
     * 캠페인 미션 가이드 조회
     */
    async getCampaignMissionGuide(requestParameters: GetCampaignMissionGuideRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.getCampaignMissionGuideRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 특정 캠페인의 썸네일 이미지 URL을 조회합니다.
     * 캠페인 썸네일 조회
     */
    async getCampaignThumbnailRaw(requestParameters: GetCampaignThumbnailRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.campaignId === null || requestParameters.campaignId === undefined) {
            throw new runtime.RequiredError('campaignId','Required parameter requestParameters.campaignId was null or undefined when calling getCampaignThumbnail.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/campaigns/{campaignId}/thumbnail`.replace(`{${"campaignId"}}`, encodeURIComponent(String(requestParameters.campaignId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * 특정 캠페인의 썸네일 이미지 URL을 조회합니다.
     * 캠페인 썸네일 조회
     */
    async getCampaignThumbnail(requestParameters: GetCampaignThumbnailRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.getCampaignThumbnailRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 신청 마감일이 가까운 순으로 캠페인을 조회합니다.  ### 필터링 옵션: - **카테고리 타입**: categoryType=방문 또는 categoryType=배송 - **카테고리명**: categoryName=맛집, 카페, 뷰티, 숙박, 식품, 화장품 등 - **캠페인 타입**: campaignType=인스타그램, 블로그, 유튜브 등
     * 마감 임박 캠페인 목록 조회
     */
    async getDeadlineSoonCampaignsRaw(requestParameters: GetDeadlineSoonCampaignsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        const queryParameters: any = {};

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.size !== undefined) {
            queryParameters['size'] = requestParameters.size;
        }

        if (requestParameters.categoryType !== undefined) {
            queryParameters['categoryType'] = requestParameters.categoryType;
        }

        if (requestParameters.categoryName !== undefined) {
            queryParameters['categoryName'] = requestParameters.categoryName;
        }

        if (requestParameters.campaignType !== undefined) {
            queryParameters['campaignType'] = requestParameters.campaignType;
        }

        if (requestParameters.includePaging !== undefined) {
            queryParameters['includePaging'] = requestParameters.includePaging;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/campaigns/deadline-soon`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * 신청 마감일이 가까운 순으로 캠페인을 조회합니다.  ### 필터링 옵션: - **카테고리 타입**: categoryType=방문 또는 categoryType=배송 - **카테고리명**: categoryName=맛집, 카페, 뷰티, 숙박, 식품, 화장품 등 - **캠페인 타입**: campaignType=인스타그램, 블로그, 유튜브 등
     * 마감 임박 캠페인 목록 조회
     */
    async getDeadlineSoonCampaigns(requestParameters: GetDeadlineSoonCampaignsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.getDeadlineSoonCampaignsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 배송형 캠페인 목록을 다양한 조건으로 조회합니다.  ### 지원하는 카테고리: - **전체**: categoryName 파라미터 생략 - **식품**: categoryName=식품 - **화장품**: categoryName=화장품 - **생활용품**: categoryName=생활용품 - **패션**: categoryName=패션 - **잡화**: categoryName=잡화  ### 플랫폼 필터링: - **단일 플랫폼**: campaignTypes=블로그 또는 campaignTypes=인스타그램 또는 campaignTypes=유튜브 - **복수 플랫폼**: campaignTypes=블로그,인스타그램 (쉼표로 구분) - **전체 플랫폼**: campaignTypes 파라미터 생략  ### 정렬 옵션: - **최신순**: sort=latest (기본값) - **선정 마감순**: sort=deadline
     * 배송 캠페인 목록 조회
     */
    async getDeliveryCampaignsRaw(requestParameters: GetDeliveryCampaignsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        const queryParameters: any = {};

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.size !== undefined) {
            queryParameters['size'] = requestParameters.size;
        }

        if (requestParameters.categoryName !== undefined) {
            queryParameters['categoryName'] = requestParameters.categoryName;
        }

        if (requestParameters.campaignTypes !== undefined) {
            queryParameters['campaignTypes'] = requestParameters.campaignTypes;
        }

        if (requestParameters.sort !== undefined) {
            queryParameters['sort'] = requestParameters.sort;
        }

        if (requestParameters.includePaging !== undefined) {
            queryParameters['includePaging'] = requestParameters.includePaging;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/campaigns/delivery`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * 배송형 캠페인 목록을 다양한 조건으로 조회합니다.  ### 지원하는 카테고리: - **전체**: categoryName 파라미터 생략 - **식품**: categoryName=식품 - **화장품**: categoryName=화장품 - **생활용품**: categoryName=생활용품 - **패션**: categoryName=패션 - **잡화**: categoryName=잡화  ### 플랫폼 필터링: - **단일 플랫폼**: campaignTypes=블로그 또는 campaignTypes=인스타그램 또는 campaignTypes=유튜브 - **복수 플랫폼**: campaignTypes=블로그,인스타그램 (쉼표로 구분) - **전체 플랫폼**: campaignTypes 파라미터 생략  ### 정렬 옵션: - **최신순**: sort=latest (기본값) - **선정 마감순**: sort=deadline
     * 배송 캠페인 목록 조회
     */
    async getDeliveryCampaigns(requestParameters: GetDeliveryCampaignsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.getDeliveryCampaignsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 최신 등록순으로 캠페인을 조회합니다.  ### 필터링 옵션: - **카테고리 타입**: categoryType=방문 또는 categoryType=배송 - **카테고리명**: categoryName=맛집, 카페, 뷰티, 숙박, 식품, 화장품 등 - **캠페인 타입**: campaignType=인스타그램, 블로그, 유튜브 등
     * 최신 캠페인 목록 조회
     */
    async getLatestCampaignsRaw(requestParameters: GetLatestCampaignsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        const queryParameters: any = {};

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.size !== undefined) {
            queryParameters['size'] = requestParameters.size;
        }

        if (requestParameters.categoryType !== undefined) {
            queryParameters['categoryType'] = requestParameters.categoryType;
        }

        if (requestParameters.categoryName !== undefined) {
            queryParameters['categoryName'] = requestParameters.categoryName;
        }

        if (requestParameters.campaignType !== undefined) {
            queryParameters['campaignType'] = requestParameters.campaignType;
        }

        if (requestParameters.includePaging !== undefined) {
            queryParameters['includePaging'] = requestParameters.includePaging;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/campaigns/latest`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * 최신 등록순으로 캠페인을 조회합니다.  ### 필터링 옵션: - **카테고리 타입**: categoryType=방문 또는 categoryType=배송 - **카테고리명**: categoryName=맛집, 카페, 뷰티, 숙박, 식품, 화장품 등 - **캠페인 타입**: campaignType=인스타그램, 블로그, 유튜브 등
     * 최신 캠페인 목록 조회
     */
    async getLatestCampaigns(requestParameters: GetLatestCampaignsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.getLatestCampaignsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 로그인한 사용자 역할에 따라 관련된 캠페인 신청 목록을 페이징 형태로 조회합니다.  ### 사용자 역할별 조회 내용: - **USER (인플루언서)**: 본인이 신청한 캠페인 목록 - **CLIENT (기업)**: 내가 만든 캠페인 목록  ### 신청 상태 (ApplicationStatus): - **PENDING**: 신청 접수 (기본값) - **APPROVED**: 선정됨 - **REJECTED**: 거절됨 - **COMPLETED**: 체험 및 리뷰 완료  ### 캠페인 승인 상태 (ApprovalStatus) - CLIENT 응답시: - **PENDING**: 관리자 승인 대기중 - **APPROVED**: 관리자 승인됨 (활성화) - **REJECTED**: 관리자 거절됨 - **EXPIRED**: 승인됐지만 모집기간이 종료됨 (만료됨)  ### 페이징 특징: - 기본 페이지 크기: 10개 - 최신순으로 자동 정렬됩니다  ### 필터링 옵션 (applicationStatus): - USER: PENDING, APPROVED, REJECTED, COMPLETED - CLIENT: PENDING, APPROVED, REJECTED, EXPIRED
     * 내 신청 목록 조회
     */
    async getMyApplicationsRaw(requestParameters: GetMyApplicationsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.authorization === null || requestParameters.authorization === undefined) {
            throw new runtime.RequiredError('authorization','Required parameter requestParameters.authorization was null or undefined when calling getMyApplications.');
        }

        const queryParameters: any = {};

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.size !== undefined) {
            queryParameters['size'] = requestParameters.size;
        }

        if (requestParameters.applicationStatus !== undefined) {
            queryParameters['applicationStatus'] = requestParameters.applicationStatus;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['Authorization'] = String(requestParameters.authorization);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/campaign-applications/my-applications`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * 로그인한 사용자 역할에 따라 관련된 캠페인 신청 목록을 페이징 형태로 조회합니다.  ### 사용자 역할별 조회 내용: - **USER (인플루언서)**: 본인이 신청한 캠페인 목록 - **CLIENT (기업)**: 내가 만든 캠페인 목록  ### 신청 상태 (ApplicationStatus): - **PENDING**: 신청 접수 (기본값) - **APPROVED**: 선정됨 - **REJECTED**: 거절됨 - **COMPLETED**: 체험 및 리뷰 완료  ### 캠페인 승인 상태 (ApprovalStatus) - CLIENT 응답시: - **PENDING**: 관리자 승인 대기중 - **APPROVED**: 관리자 승인됨 (활성화) - **REJECTED**: 관리자 거절됨 - **EXPIRED**: 승인됐지만 모집기간이 종료됨 (만료됨)  ### 페이징 특징: - 기본 페이지 크기: 10개 - 최신순으로 자동 정렬됩니다  ### 필터링 옵션 (applicationStatus): - USER: PENDING, APPROVED, REJECTED, COMPLETED - CLIENT: PENDING, APPROVED, REJECTED, EXPIRED
     * 내 신청 목록 조회
     */
    async getMyApplications(requestParameters: GetMyApplicationsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.getMyApplicationsRaw(requestParameters, initOverrides);
    }

    /**
     * 사용자 역할에 따른 캠페인 카테고리별 요약 정보를 조회합니다.  ### USER 역할 - **지원**: 내가 신청한 모든 캠페인 수 - **대기중**: 심사 대기중인 신청 수 - **선정**: 선정된 신청 수 - **완료**: 완료한 신청 수  ### CLIENT 역할 - **대기중**: 관리자 승인 대기중인 캠페인 수 - **승인됨**: 승인되어 활성화된 캠페인 수 - **거절됨**: 관리자가 거절한 캠페인 수 - **만료됨**: 승인됐지만 신청기간이 종료된 캠페인 수
     * 내 캠페인 요약 조회
     */
    async getMyCampaignSummaryRaw(requestParameters: GetMyCampaignSummaryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.authorization === null || requestParameters.authorization === undefined) {
            throw new runtime.RequiredError('authorization','Required parameter requestParameters.authorization was null or undefined when calling getMyCampaignSummary.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['Authorization'] = String(requestParameters.authorization);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/my-campaigns/summary`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * 사용자 역할에 따른 캠페인 카테고리별 요약 정보를 조회합니다.  ### USER 역할 - **지원**: 내가 신청한 모든 캠페인 수 - **대기중**: 심사 대기중인 신청 수 - **선정**: 선정된 신청 수 - **완료**: 완료한 신청 수  ### CLIENT 역할 - **대기중**: 관리자 승인 대기중인 캠페인 수 - **승인됨**: 승인되어 활성화된 캠페인 수 - **거절됨**: 관리자가 거절한 캠페인 수 - **만료됨**: 승인됐지만 신청기간이 종료된 캠페인 수
     * 내 캠페인 요약 조회
     */
    async getMyCampaignSummary(requestParameters: GetMyCampaignSummaryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.getMyCampaignSummaryRaw(requestParameters, initOverrides);
    }

    /**
     * 신청 인원이 많은 순으로 캠페인을 조회합니다.  ### 필터링 옵션: - **카테고리 타입**: categoryType=방문 또는 categoryType=배송 - **카테고리명**: categoryName=맛집, 카페, 뷰티, 숙박, 식품, 화장품 등 - **캠페인 타입**: campaignType=인스타그램, 블로그, 유튜브 등
     * 인기 캠페인 목록 조회
     */
    async getPopularCampaignsRaw(requestParameters: GetPopularCampaignsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        const queryParameters: any = {};

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.size !== undefined) {
            queryParameters['size'] = requestParameters.size;
        }

        if (requestParameters.categoryType !== undefined) {
            queryParameters['categoryType'] = requestParameters.categoryType;
        }

        if (requestParameters.categoryName !== undefined) {
            queryParameters['categoryName'] = requestParameters.categoryName;
        }

        if (requestParameters.campaignType !== undefined) {
            queryParameters['campaignType'] = requestParameters.campaignType;
        }

        if (requestParameters.includePaging !== undefined) {
            queryParameters['includePaging'] = requestParameters.includePaging;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/campaigns/popular`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * 신청 인원이 많은 순으로 캠페인을 조회합니다.  ### 필터링 옵션: - **카테고리 타입**: categoryType=방문 또는 categoryType=배송 - **카테고리명**: categoryName=맛집, 카페, 뷰티, 숙박, 식품, 화장품 등 - **캠페인 타입**: campaignType=인스타그램, 블로그, 유튜브 등
     * 인기 캠페인 목록 조회
     */
    async getPopularCampaigns(requestParameters: GetPopularCampaignsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.getPopularCampaignsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * accessToken으로 로그인한 유저 정보를 가져옵니다.
     * 내 정보 조회
     */
    async getProfileRaw(requestParameters: GetProfileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserProfileResponseDTO>> {
        if (requestParameters.authorization === null || requestParameters.authorization === undefined) {
            throw new runtime.RequiredError('authorization','Required parameter requestParameters.authorization was null or undefined when calling getProfile.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['Authorization'] = String(requestParameters.authorization);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/users/profile`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserProfileResponseDTOFromJSON(jsonValue));
    }

    /**
     * accessToken으로 로그인한 유저 정보를 가져옵니다.
     * 내 정보 조회
     */
    async getProfile(requestParameters: GetProfileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserProfileResponseDTO> {
        const response = await this.getProfileRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 사용자들이 실제로 많이 검색한 캠페인 키워드를 실시간으로 제공합니다.  ### 주요 기능: - 사용자들이 실제로 검색한 키워드 기반의 실시간 통계 - Redis 기반의 실시간 데이터 집계 - 검색창 초기 상태에서 검색 힌트로 활용 가능 - 최대 20개의 인기 키워드 제공  ### 데이터 특징: - **실시간성**: 사용자 검색 시마다 실시간 업데이트 - **인기순 정렬**: 검색 빈도가 높은 순으로 정렬 - **자동 갱신**: 7일 주기로 오래된 데이터 자동 삭제 - **Fallback**: 데이터 없으면 빈 배열 반환
     * 실시간 인기 검색어 조회
     */
    async getRealtimeTrendingKeywordsRaw(requestParameters: GetRealtimeTrendingKeywordsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/campaigns/search/realtime`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * 사용자들이 실제로 많이 검색한 캠페인 키워드를 실시간으로 제공합니다.  ### 주요 기능: - 사용자들이 실제로 검색한 키워드 기반의 실시간 통계 - Redis 기반의 실시간 데이터 집계 - 검색창 초기 상태에서 검색 힌트로 활용 가능 - 최대 20개의 인기 키워드 제공  ### 데이터 특징: - **실시간성**: 사용자 검색 시마다 실시간 업데이트 - **인기순 정렬**: 검색 빈도가 높은 순으로 정렬 - **자동 갱신**: 7일 주기로 오래된 데이터 자동 삭제 - **Fallback**: 데이터 없으면 빈 배열 반환
     * 실시간 인기 검색어 조회
     */
    async getRealtimeTrendingKeywords(requestParameters: GetRealtimeTrendingKeywordsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.getRealtimeTrendingKeywordsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 입력된 키워드를 기반으로 캠페인 제목에서 자동완성 제안을 제공.
     * 검색 자동완성 제안
     */
    async getSearchSuggestionsRaw(requestParameters: GetSearchSuggestionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.q === null || requestParameters.q === undefined) {
            throw new runtime.RequiredError('q','Required parameter requestParameters.q was null or undefined when calling getSearchSuggestions.');
        }

        const queryParameters: any = {};

        if (requestParameters.q !== undefined) {
            queryParameters['q'] = requestParameters.q;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/campaigns/search/suggestions`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * 입력된 키워드를 기반으로 캠페인 제목에서 자동완성 제안을 제공.
     * 검색 자동완성 제안
     */
    async getSearchSuggestions(requestParameters: GetSearchSuggestionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.getSearchSuggestionsRaw(requestParameters, initOverrides);
    }

    /**
     * 방문형 캠페인 목록을 다양한 조건으로 조회합니다.  ### 지원하는 카테고리: - **전체**: categoryName 파라미터 생략 - **맛집**: categoryName=맛집 - **카페**: categoryName=카페 - **뷰티**: categoryName=뷰티 - **숙박**: categoryName=숙박  ### 플랫폼 필터링: - **단일 플랫폼**: campaignTypes=블로그 또는 campaignTypes=인스타그램 또는 campaignTypes=유튜브 - **복수 플랫폼**: campaignTypes=블로그,인스타그램 (쉼표로 구분) - **전체 플랫폼**: campaignTypes 파라미터 생략  ### 정렬 옵션: - **최신순**: sort=latest (기본값) - **선정 마감순**: sort=deadline
     * 방문 캠페인 목록 조회
     */
    async getVisitCampaignsRaw(requestParameters: GetVisitCampaignsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        const queryParameters: any = {};

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.size !== undefined) {
            queryParameters['size'] = requestParameters.size;
        }

        if (requestParameters.categoryName !== undefined) {
            queryParameters['categoryName'] = requestParameters.categoryName;
        }

        if (requestParameters.campaignTypes !== undefined) {
            queryParameters['campaignTypes'] = requestParameters.campaignTypes;
        }

        if (requestParameters.sort !== undefined) {
            queryParameters['sort'] = requestParameters.sort;
        }

        if (requestParameters.includePaging !== undefined) {
            queryParameters['includePaging'] = requestParameters.includePaging;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/campaigns/visit`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * 방문형 캠페인 목록을 다양한 조건으로 조회합니다.  ### 지원하는 카테고리: - **전체**: categoryName 파라미터 생략 - **맛집**: categoryName=맛집 - **카페**: categoryName=카페 - **뷰티**: categoryName=뷰티 - **숙박**: categoryName=숙박  ### 플랫폼 필터링: - **단일 플랫폼**: campaignTypes=블로그 또는 campaignTypes=인스타그램 또는 campaignTypes=유튜브 - **복수 플랫폼**: campaignTypes=블로그,인스타그램 (쉼표로 구분) - **전체 플랫폼**: campaignTypes 파라미터 생략  ### 정렬 옵션: - **최신순**: sort=latest (기본값) - **선정 마감순**: sort=deadline
     * 방문 캠페인 목록 조회
     */
    async getVisitCampaigns(requestParameters: GetVisitCampaignsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.getVisitCampaignsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 인가코드와 리다이렉트 URI를 전달받아 JWT를 발급합니다.
     * 카카오 로그인
     */
    async kakaoLoginRaw(requestParameters: KakaoLoginRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<LoginResponseDTO>> {
        if (requestParameters.kakaoAuthRequest === null || requestParameters.kakaoAuthRequest === undefined) {
            throw new runtime.RequiredError('kakaoAuthRequest','Required parameter requestParameters.kakaoAuthRequest was null or undefined when calling kakaoLogin.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/auth/kakao`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: KakaoAuthRequestToJSON(requestParameters.kakaoAuthRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LoginResponseDTOFromJSON(jsonValue));
    }

    /**
     * 인가코드와 리다이렉트 URI를 전달받아 JWT를 발급합니다.
     * 카카오 로그인
     */
    async kakaoLogin(requestParameters: KakaoLoginRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<LoginResponseDTO> {
        const response = await this.kakaoLoginRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * accessToken을 블랙리스트 처리하고 refreshToken을 제거합니다.
     * 로그아웃
     */
    async logoutRaw(requestParameters: LogoutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Success>> {
        if (requestParameters.authorization === null || requestParameters.authorization === undefined) {
            throw new runtime.RequiredError('authorization','Required parameter requestParameters.authorization was null or undefined when calling logout.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['Authorization'] = String(requestParameters.authorization);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/auth/logout`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SuccessFromJSON(jsonValue));
    }

    /**
     * accessToken을 블랙리스트 처리하고 refreshToken을 제거합니다.
     * 로그아웃
     */
    async logout(requestParameters: LogoutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Success> {
        const response = await this.logoutRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 프론트에서 받은 redirectUri를 기반으로 카카오 로그인 페이지로 직접 리다이렉트합니다.
     * 카카오 로그인 리다이렉트
     */
    async redirectToKakaoLoginRaw(requestParameters: RedirectToKakaoLoginRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.redirectUri === null || requestParameters.redirectUri === undefined) {
            throw new runtime.RequiredError('redirectUri','Required parameter requestParameters.redirectUri was null or undefined when calling redirectToKakaoLogin.');
        }

        const queryParameters: any = {};

        if (requestParameters.redirectUri !== undefined) {
            queryParameters['redirectUri'] = requestParameters.redirectUri;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/auth/login-redirect`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * 프론트에서 받은 redirectUri를 기반으로 카카오 로그인 페이지로 직접 리다이렉트합니다.
     * 카카오 로그인 리다이렉트
     */
    async redirectToKakaoLogin(requestParameters: RedirectToKakaoLoginRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.redirectToKakaoLoginRaw(requestParameters, initOverrides);
    }

    /**
     * accessToken과 refreshToken을 이용해 새 토큰을 발급합니다.
     * 토큰 재발급
     */
    async refreshRaw(requestParameters: RefreshRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TokenRefreshResponseDTO>> {
        if (requestParameters.authorization === null || requestParameters.authorization === undefined) {
            throw new runtime.RequiredError('authorization','Required parameter requestParameters.authorization was null or undefined when calling refresh.');
        }

        if (requestParameters.refreshTokenRequest === null || requestParameters.refreshTokenRequest === undefined) {
            throw new runtime.RequiredError('refreshTokenRequest','Required parameter requestParameters.refreshTokenRequest was null or undefined when calling refresh.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['Authorization'] = String(requestParameters.authorization);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/auth/refresh`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RefreshTokenRequestToJSON(requestParameters.refreshTokenRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TokenRefreshResponseDTOFromJSON(jsonValue));
    }

    /**
     * accessToken과 refreshToken을 이용해 새 토큰을 발급합니다.
     * 토큰 재발급
     */
    async refresh(requestParameters: RefreshRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TokenRefreshResponseDTO> {
        const response = await this.refreshRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 키워드로 캠페인을 검색합니다.  ### 검색 기능: - **키워드**: 캠페인 제목에서 검색 - **정렬**: 최신순으로 고정 - **페이징**: 페이지별 조회 지원 - **통계 수집**: 검색어를 실시간 인기 검색어에 자동 반영  ### 사용 예시: - `keyword=맛집` - \'맛집\'이 포함된 캠페인 검색 - `keyword=화장품` - \'화장품\' 캠페인을 최신순으로 검색
     * 캠페인 검색
     */
    async searchCampaignsRaw(requestParameters: SearchCampaignsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.keyword === null || requestParameters.keyword === undefined) {
            throw new runtime.RequiredError('keyword','Required parameter requestParameters.keyword was null or undefined when calling searchCampaigns.');
        }

        const queryParameters: any = {};

        if (requestParameters.keyword !== undefined) {
            queryParameters['keyword'] = requestParameters.keyword;
        }

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.size !== undefined) {
            queryParameters['size'] = requestParameters.size;
        }

        if (requestParameters.includePaging !== undefined) {
            queryParameters['includePaging'] = requestParameters.includePaging;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/campaigns/search`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * 키워드로 캠페인을 검색합니다.  ### 검색 기능: - **키워드**: 캠페인 제목에서 검색 - **정렬**: 최신순으로 고정 - **페이징**: 페이지별 조회 지원 - **통계 수집**: 검색어를 실시간 인기 검색어에 자동 반영  ### 사용 예시: - `keyword=맛집` - \'맛집\'이 포함된 캠페인 검색 - `keyword=화장품` - \'화장품\' 캠페인을 최신순으로 검색
     * 캠페인 검색
     */
    async searchCampaigns(requestParameters: SearchCampaignsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.searchCampaignsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 기존 캠페인 정보를 수정합니다.  ### 수정 조건: - 본인이 생성한 캠페인만 수정 가능 - 승인된 캠페인은 수정할 수 없음 - 수정 후 승인 상태가 PENDING으로 변경됨  ### 카테고리 지정: - ID가 아닌 **타입과 이름**으로 지정 - 방문형: 맛집, 카페, 뷰티, 숙박 - 배송형: 식품, 화장품, 생활용품, 패션, 잡화
     * 캠페인 수정
     */
    async updateCampaignRaw(requestParameters: UpdateCampaignRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.authorization === null || requestParameters.authorization === undefined) {
            throw new runtime.RequiredError('authorization','Required parameter requestParameters.authorization was null or undefined when calling updateCampaign.');
        }

        if (requestParameters.campaignId === null || requestParameters.campaignId === undefined) {
            throw new runtime.RequiredError('campaignId','Required parameter requestParameters.campaignId was null or undefined when calling updateCampaign.');
        }

        if (requestParameters.createCampaignRequest === null || requestParameters.createCampaignRequest === undefined) {
            throw new runtime.RequiredError('createCampaignRequest','Required parameter requestParameters.createCampaignRequest was null or undefined when calling updateCampaign.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['Authorization'] = String(requestParameters.authorization);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/campaigns/{campaignId}`.replace(`{${"campaignId"}}`, encodeURIComponent(String(requestParameters.campaignId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: CreateCampaignRequestToJSON(requestParameters.createCampaignRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * 기존 캠페인 정보를 수정합니다.  ### 수정 조건: - 본인이 생성한 캠페인만 수정 가능 - 승인된 캠페인은 수정할 수 없음 - 수정 후 승인 상태가 PENDING으로 변경됨  ### 카테고리 지정: - ID가 아닌 **타입과 이름**으로 지정 - 방문형: 맛집, 카페, 뷰티, 숙박 - 배송형: 식품, 화장품, 생활용품, 패션, 잡화
     * 캠페인 수정
     */
    async updateCampaign(requestParameters: UpdateCampaignRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.updateCampaignRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 사용자의 닉네임만 수정합니다. 닉네임 중복 검사가 이루어집니다.
     * 닉네임 수정
     */
    async updateNicknameRaw(requestParameters: UpdateNicknameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.authorization === null || requestParameters.authorization === undefined) {
            throw new runtime.RequiredError('authorization','Required parameter requestParameters.authorization was null or undefined when calling updateNickname.');
        }

        if (requestParameters.nicknameUpdateRequest === null || requestParameters.nicknameUpdateRequest === undefined) {
            throw new runtime.RequiredError('nicknameUpdateRequest','Required parameter requestParameters.nicknameUpdateRequest was null or undefined when calling updateNickname.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['Authorization'] = String(requestParameters.authorization);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/users/profile/nickname`,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: NicknameUpdateRequestToJSON(requestParameters.nicknameUpdateRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * 사용자의 닉네임만 수정합니다. 닉네임 중복 검사가 이루어집니다.
     * 닉네임 수정
     */
    async updateNickname(requestParameters: UpdateNicknameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.updateNicknameRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 사용자 정보를 수정합니다. 소셜 로그인으로 제공된 이메일은 수정할 수 없습니다.
     * 내 정보 수정
     */
    async updateProfileRaw(requestParameters: UpdateProfileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserProfileResponseDTO>> {
        if (requestParameters.authorization === null || requestParameters.authorization === undefined) {
            throw new runtime.RequiredError('authorization','Required parameter requestParameters.authorization was null or undefined when calling updateProfile.');
        }

        if (requestParameters.userUpdateRequest === null || requestParameters.userUpdateRequest === undefined) {
            throw new runtime.RequiredError('userUpdateRequest','Required parameter requestParameters.userUpdateRequest was null or undefined when calling updateProfile.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['Authorization'] = String(requestParameters.authorization);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/users/profile`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UserUpdateRequestToJSON(requestParameters.userUpdateRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserProfileResponseDTOFromJSON(jsonValue));
    }

    /**
     * 사용자 정보를 수정합니다. 소셜 로그인으로 제공된 이메일은 수정할 수 없습니다.
     * 내 정보 수정
     */
    async updateProfile(requestParameters: UpdateProfileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserProfileResponseDTO> {
        const response = await this.updateProfileRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 사용자의 프로필 이미지만 수정합니다.
     * 프로필 이미지 수정
     */
    async updateProfileImageRaw(requestParameters: UpdateProfileImageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.authorization === null || requestParameters.authorization === undefined) {
            throw new runtime.RequiredError('authorization','Required parameter requestParameters.authorization was null or undefined when calling updateProfileImage.');
        }

        if (requestParameters.profileImageUpdateRequest === null || requestParameters.profileImageUpdateRequest === undefined) {
            throw new runtime.RequiredError('profileImageUpdateRequest','Required parameter requestParameters.profileImageUpdateRequest was null or undefined when calling updateProfileImage.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['Authorization'] = String(requestParameters.authorization);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/users/profile/image`,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: ProfileImageUpdateRequestToJSON(requestParameters.profileImageUpdateRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * 사용자의 프로필 이미지만 수정합니다.
     * 프로필 이미지 수정
     */
    async updateProfileImage(requestParameters: UpdateProfileImageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.updateProfileImageRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
